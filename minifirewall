#!/bin/sh

# minifirewall is shellscripts for easy firewalling on a standalone server
# we used netfilter/iptables http://netfilter.org/ designed for recent Linux kernel
# See https://gitea.evolix.org/evolix/minifirewall

# Copyright (c) 2007-2021 Evolix
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License.

# Description
# script for standalone server

# Start or stop minifirewall
#

### BEGIN INIT INFO
# Provides:          minfirewall
# Required-Start:
# Required-Stop:
# Should-Start:      $network $syslog $named
# Should-Stop:       $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: start and stop the firewall
# Description:       Firewall designed for standalone server
### END INIT INFO

VERSION="21.09"

DESC="minifirewall"
NAME="minifirewall"

set -u


# Variables configuration
#########################

# iptables paths
IPT=$(command -v iptables)
if [ -z "${IPT}" ]; then
    echo "Unable to find 'iptables\` command in PATH." >&2
    exit 1
fi
IPT6=$(command -v ip6tables)
if [ -z "${IPT6}" ]; then
    echo "Unable to find 'ip6tables\` command in PATH." >&2
    exit 1
fi

# TCP/IP variables
LOOPBACK='127.0.0.0/8'
CLASSA='10.0.0.0/8'
CLASSB='172.16.0.0/12'
CLASSC='192.168.0.0/16'
CLASSD='224.0.0.0/4'
CLASSE='240.0.0.0/5'
ALL='0.0.0.0'
BROAD='255.255.255.255'
PORTSROOT='0:1023'
PORTSUSER='1024:65535'

# Configuration

INT=''
IPV6=''
DOCKER=''
INTLAN=''
TRUSTEDIPS=''
PRIVILEGIEDIPS=''
SERVICESTCP1p=''
SERVICESUDP1p=''
SERVICESTCP1=''
SERVICESUDP1=''
SERVICESTCP2=''
SERVICESUDP2=''
SERVICESTCP3=''
SERVICESUDP3=''
DNSSERVEURS=''
HTTPSITES=''
HTTPSSITES=''
FTPSITES=''
SSHOK=''
SMTPOK=''
SMTPSECUREOK=''
NTPOK=''
PROXY=''
PROXYBYPASS=''
PROXYPORT=''
BACKUPSERVERS=''

legacy_config_file="/etc/firewall.rc"
config_file="/etc/default/minifirewall"
includes_dir="/etc/minifirewall.d"

IPV6=$(grep "IPV6=" "${config_file}" | awk -F '=' -F "'" '{print $2}')
DOCKER=$(grep "DOCKER=" "${config_file}" | awk -F '='  -F "'" '{print $2}')
INT=$(grep "INT=" "${config_file}" | awk -F '='  -F "'" '{print $2}')

is_ipv6_enabled() {
    test "${IPV6}" != "off"
}
is_docker_enabled() {
    test "${DOCKER}" = "on"
}
is_proxy_enabled() {
    test "${PROXY}" = "on"
}
is_ipv6() {
    grep -q ':' "$1"
}
chain_exists() {
    chain_name="$1"
    if [ $# -ge 2 ]; then
        intable="--table $2"
    fi
    # shellcheck disable=SC2086
    iptables ${intable} -nL "${chain_name}" >/dev/null 2>&1
}
source_file_or_error() {
    file=$1
    echo "...sourcing '${file}\`"

    tmpfile=$(mktemp --tmpdir=/tmp minifirewall.XXX)
    . "${file}" 2>"${tmpfile}" >&2
    if [ -s "${tmpfile}" ]; then
            echo "${file} returns standard or error output (see below). Stopping." >&2
            cat "${tmpfile}"
            exit 1
    fi
    rm "${tmpfile}"
}
source_configuration() {
    if test -f ${legacy_config_file}; then
        echo "${legacy_config_file} is deprecated, rename to ${config_file}" >&2
        exit 1
    fi

    if ! test -f ${config_file}; then
        echo "${config_file} does not exist" >&2
        exit 1
    fi

    source_file_or_error ${config_file}

    if [ -d "${includes_dir}" ]; then
        include_files=$(find ${includes_dir} -type f -readable -not -name '*.*')
        for include_file in ${include_files}; do
            source_file_or_error "${include_file}"
        done
    fi
}

start() {
    echo "Start IPTables rules..."

    # Stop and warn if error!
    set -e
    trap 'echo "ERROR in minifirewall configuration (fix it now!) or script manipulation (fix yourself)." ' INT TERM EXIT


    # sysctl network security settings
    ##################################

    # Don't answer to broadcast pings
    echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts

    # Ignore bogus ICMP responses
    echo 1 > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses

    # Disable Source Routing
    for proc_sys_file in /proc/sys/net/ipv4/conf/*/accept_source_route; do
        echo 0 > "${proc_sys_file}"
    done

    # Enable TCP SYN cookies to avoid TCP-SYN-FLOOD attacks
    # cf http://cr.yp.to/syncookies.html
    echo 1 > /proc/sys/net/ipv4/tcp_syncookies

    # Disable ICMP redirects
    for proc_sys_file in /proc/sys/net/ipv4/conf/*/accept_redirects; do
        echo 0 > "${proc_sys_file}"
    done

    for proc_sys_file in /proc/sys/net/ipv4/conf/*/send_redirects; do
        echo 0 > "${proc_sys_file}"
    done

    # Enable Reverse Path filtering : verify if responses use same network interface
    for proc_sys_file in /proc/sys/net/ipv4/conf/*/rp_filter; do
        echo 1 > "${proc_sys_file}"
    done

    # log des paquets avec adresse incoherente
    for proc_sys_file in /proc/sys/net/ipv4/conf/*/log_martians; do
        echo 1 > "${proc_sys_file}"
    done

    # IPTables configuration
    ########################

    ${IPT} -N LOG_DROP
    ${IPT} -A LOG_DROP -j LOG  --log-prefix '[IPTABLES DROP] : '
    ${IPT} -A LOG_DROP -j DROP
    ${IPT} -N LOG_ACCEPT
    ${IPT} -A LOG_ACCEPT -j LOG  --log-prefix '[IPTABLES ACCEPT] : '
    ${IPT} -A LOG_ACCEPT -j ACCEPT

    source_configuration

    # Trusted ip addresses
    ${IPT} -N ONLYTRUSTED
    ${IPT} -A ONLYTRUSTED -j LOG_DROP
    for ip in ${TRUSTEDIPS}; do
        ${IPT} -I ONLYTRUSTED -s ${ip} -j ACCEPT
    done

    # Privilegied ip addresses
    # (trusted ip addresses *are* privilegied)
    ${IPT} -N ONLYPRIVILEGIED
    ${IPT} -A ONLYPRIVILEGIED -j ONLYTRUSTED
    for ip in ${PRIVILEGIEDIPS}; do
        ${IPT} -I ONLYPRIVILEGIED -s ${ip} -j ACCEPT
    done

    # Chain for restrictions (blacklist IPs/ranges)
    ${IPT} -N NEEDRESTRICT

    # We allow all on loopback interface
    ${IPT} -A INPUT -i lo -j ACCEPT
    if is_ipv6_enabled; then
        ${IPT6} -A INPUT -i lo -j ACCEPT
    fi
    # if OUTPUTDROP
    ${IPT} -A OUTPUT -o lo -j ACCEPT
    if is_ipv6_enabled; then
        ${IPT6} -A OUTPUT -o lo -j ACCEPT
    fi

    # We avoid "martians" packets, typical when W32/Blaster virus
    # attacked windowsupdate.com and DNS was changed to 127.0.0.1
    # ${IPT} -t NAT -I PREROUTING -s ${LOOPBACK} -i ! lo -j DROP
    ${IPT} -A INPUT -s ${LOOPBACK} ! -i lo -j DROP

    if is_docker_enabled; then
        ${IPT} -N MINIFW-DOCKER-TRUSTED
        ${IPT} -A MINIFW-DOCKER-TRUSTED -j DROP

        ${IPT} -N MINIFW-DOCKER-PRIVILEGED
        ${IPT} -A MINIFW-DOCKER-PRIVILEGED -j MINIFW-DOCKER-TRUSTED
        ${IPT} -A MINIFW-DOCKER-PRIVILEGED -j RETURN

        ${IPT} -N MINIFW-DOCKER-PUB
        ${IPT} -A MINIFW-DOCKER-PUB -j MINIFW-DOCKER-PRIVILEGED
        ${IPT} -A MINIFW-DOCKER-PUB -j RETURN

        # Flush DOCKER-USER if exist, create it if absent
        if chain_exists 'DOCKER-USER'; then
            ${IPT} -F DOCKER-USER
        else
            ${IPT} -N DOCKER-USER
        fi;

        # Pipe new connection through MINIFW-DOCKER-PUB
        ${IPT} -A DOCKER-USER -i ${INT} -m state  --state NEW -j MINIFW-DOCKER-PUB
        ${IPT} -A DOCKER-USER -j RETURN
    fi


    # Local services restrictions
    #############################

    # Allow services for ${INTLAN} (local server or local network)
    ${IPT} -A INPUT -s ${INTLAN} -j ACCEPT

    # Enable protection chain for sensible services
    for port in ${SERVICESTCP1p}; do
        ${IPT} -A INPUT -p tcp --dport ${port} -j NEEDRESTRICT
    done

    for port in ${SERVICESUDP1p}; do
        ${IPT} -A INPUT -p udp --dport ${port} -j NEEDRESTRICT
    done

    # Public service
    for port in ${SERVICESTCP1}; do
        ${IPT} -A INPUT -p tcp --dport ${port} -j ACCEPT
        if is_ipv6_enabled; then
            ${IPT6} -A INPUT -p tcp --dport ${port} -j ACCEPT
        fi
    done

    for port in ${SERVICESUDP1}; do
        ${IPT} -A INPUT -p udp --dport ${port} -j ACCEPT
        if is_ipv6_enabled; then
            ${IPT6} -A INPUT -p udp --dport ${port} -j ACCEPT
        fi
    done

    # Privilegied services
    for port in ${SERVICESTCP2}; do
        ${IPT} -A INPUT -p tcp --dport ${port} -j ONLYPRIVILEGIED
    done

    for port in ${SERVICESUDP2}; do
        ${IPT} -A INPUT -p udp --dport ${port} -j ONLYPRIVILEGIED
    done

    # Private services
    for port in ${SERVICESTCP3}; do
        ${IPT} -A INPUT -p tcp --dport ${port} -j ONLYTRUSTED
    done

    for port in ${SERVICESUDP3}; do
        ${IPT} -A INPUT -p udp --dport ${port} -j ONLYTRUSTED
    done


    if is_docker_enabled; then
        # Public services defined in SERVICESTCP1 & SERVICESUDP1
        for dstport in ${SERVICESTCP1}; do
            ${IPT} -I MINIFW-DOCKER-PUB -p tcp --dport "${dstport}" -j RETURN
        done

        for dstport in ${SERVICESUDP1}; do
            ${IPT} -I MINIFW-DOCKER-PUB -p udp --dport "${dstport}" -j RETURN
        done

        # Privileged services (accessible from privileged & trusted IPs)
        for dstport in ${SERVICESTCP2}; do
            for srcip in ${PRIVILEGIEDIPS}; do
                ${IPT} -I MINIFW-DOCKER-PRIVILEGED -p tcp -s "${srcip}" --dport "${dstport}" -j RETURN
            done

            for srcip in ${TRUSTEDIPS}; do
                ${IPT} -I MINIFW-DOCKER-PRIVILEGED -p tcp -s "${srcip}" --dport "${dstport}" -j RETURN
            done
        done

        for dstport in ${SERVICESUDP2}; do
            for srcip in ${PRIVILEGIEDIPS}; do
                ${IPT} -I MINIFW-DOCKER-PRIVILEGED -p udp -s "${srcip}" --dport "${dstport}" -j RETURN
            done

            for srcip in ${TRUSTEDIPS}; do
                ${IPT} -I MINIFW-DOCKER-PRIVILEGED -p udp -s "${srcip}" --dport "${dstport}" -j RETURN
            done
        done

        # Trusted services (accessible from trusted IPs)
        for dstport in ${SERVICESTCP3}; do
            for srcip in ${TRUSTEDIPS}; do
                ${IPT} -I MINIFW-DOCKER-TRUSTED -p tcp -s "${srcip}" --dport "${dstport}" -j RETURN
            done
        done

        for dstport in ${SERVICESUDP3}; do
            for srcip in ${TRUSTEDIPS}; do
                ${IPT} -I MINIFW-DOCKER-TRUSTED -p udp -s "${srcip}" --dport "${dstport}" -j RETURN
            done
        done
    fi

    # External services
    ###################

    # DNS authorizations
    for src in ${DNSSERVEURS}; do
        ${IPT} -A INPUT -p tcp ! --syn --sport 53 --dport ${PORTSUSER} -s ${src} -j ACCEPT
        ${IPT} -A INPUT -p udp --sport 53 --dport ${PORTSUSER} -s ${src} -m state --state ESTABLISHED,RELATED -j ACCEPT
        ${IPT} -A OUTPUT -o ${INT} -p udp -d ${src} --dport 53 --match state --state NEW -j ACCEPT
    done

    # HTTP (TCP/80) authorizations
    for src in ${HTTPSITES}; do
        ${IPT} -A INPUT -p tcp ! --syn --sport 80 --dport ${PORTSUSER} -s ${src} -j ACCEPT
    done

    # HTTPS (TCP/443) authorizations
    for src in ${HTTPSSITES}; do
        ${IPT} -A INPUT -p tcp ! --syn --sport 443 --dport ${PORTSUSER} -s ${src} -j ACCEPT
    done

    # FTP (so complex protocol...) authorizations
    for src in ${FTPSITES}; do
        # requests on Control connection
        ${IPT} -A INPUT -p tcp ! --syn --sport 21 --dport ${PORTSUSER} -s ${src} -j ACCEPT
        # FTP port-mode on Data Connection
        ${IPT} -A INPUT -p tcp --sport 20 --dport ${PORTSUSER} -s ${src} -j ACCEPT
        # FTP passive-mode on Data Connection
        # WARNING, this allow all connections on TCP ports > 1024
        ${IPT} -A INPUT -p tcp ! --syn --sport ${PORTSUSER} --dport ${PORTSUSER} -s ${src} -j ACCEPT
    done

    # SSH authorizations
    for src in ${SSHOK}; do
        ${IPT} -A INPUT -p tcp ! --syn --sport 22 -s ${src} -j ACCEPT
    done

    # SMTP authorizations
    for src in ${SMTPOK}; do
        ${IPT} -A INPUT -p tcp ! --syn --sport 25 --dport ${PORTSUSER} -s ${src} -j ACCEPT
    done

    # secure SMTP (TCP/465 et TCP/587) authorizations
    for src in ${SMTPSECUREOK}; do
        ${IPT} -A INPUT -p tcp ! --syn --sport 465 --dport ${PORTSUSER} -s ${src} -j ACCEPT
        ${IPT} -A INPUT -p tcp ! --syn --sport 587 --dport ${PORTSUSER} -s ${src} -j ACCEPT
    done

    # NTP authorizations
    for src in ${NTPOK}; do
        ${IPT} -A INPUT -p udp --sport 123 -s ${src} -j ACCEPT
        ${IPT} -A OUTPUT -o ${INT} -p udp -d ${src} --dport 123 --match state --state NEW -j ACCEPT
    done

    # Proxy (Squid)
    if is_proxy_enabled; then
        ${IPT} -t nat -A OUTPUT -p tcp --dport 80 -m owner --uid-owner proxy -j ACCEPT
        for dstip in ${PROXYBYPASS}; do
            ${IPT} -t nat -A OUTPUT -p tcp --dport 80 -d "${dstip}" -j ACCEPT
        done
        ${IPT} -t nat -A OUTPUT -p tcp --dport 80 -j REDIRECT --to-port "${PROXYPORT:-'8888'}"
    fi

    # Output for backup servers
    for server in ${BACKUPSERVERS}; do
        server_ip=$(echo "${server}" | cut -d ':' -f1)
        server_port=$(echo "${server}" | cut -d ':' -f2)
        if [ -n "${server_ip}" ] && [ -n "${server_port}" ]; then
            ${IPT} -A INPUT -p tcp --sport "${server_port}" --dport 1024:65535 -s "${server_ip}" -m state --state ESTABLISHED,RELATED -j ACCEPT
        else
            echo "Unrecognized syntax for BACKUPSERVERS '${server}\`. Use space-separated IP:PORT tuples." >&2
            exit 1
        fi
    done

    # Always allow ICMP
    ${IPT} -A INPUT -p icmp -j ACCEPT
    if is_ipv6_enabled; then
        ${IPT6} -A INPUT -p icmpv6 -j ACCEPT
    fi


    # IPTables policy
    #################

    # by default DROP INPUT packets
    ${IPT} -P INPUT DROP
    if is_ipv6_enabled; then
        ${IPT6} -P INPUT DROP
    fi

    # by default, no FORWARDING (deprecated for Virtual Machines)
    #echo 0 > /proc/sys/net/ipv4/ip_forward
    #${IPT} -P FORWARD DROP
    #${IPT6} -P FORWARD DROP

    # by default allow OUTPUT packets... but drop UDP packets (see OUTPUTDROP to drop OUTPUT packets)
    ${IPT} -P OUTPUT ACCEPT
    if is_ipv6_enabled; then
        ${IPT6} -P OUTPUT ACCEPT
    fi
    
    ${IPT} -A OUTPUT -o ${INT} -p udp --dport 33434:33523 --match state --state NEW -j ACCEPT
    if is_ipv6_enabled; then
        ${IPT6} -A OUTPUT -o ${INT} -p udp --dport 33434:33523 --match state --state NEW -j ACCEPT
    fi
    
    ${IPT} -A OUTPUT -p udp --match state --state ESTABLISHED,RELATED -j ACCEPT
    if is_ipv6_enabled; then
        ${IPT6} -A OUTPUT -p udp --match state --state ESTABLISHED,RELATED -j ACCEPT
    fi

    ${IPT} -A OUTPUT -p udp -j DROP
    if is_ipv6_enabled; then
        ${IPT6} -A OUTPUT -p udp -j DROP
    fi

    trap - INT TERM EXIT

    echo "...starting IPTables rules is now finish : OK"
}

stop() {
    echo "Flush all rules and accept everything..."

    # Delete all rules
    ${IPT} -F INPUT
    if is_ipv6_enabled; then
        ${IPT6} -F INPUT
    fi
    
    ${IPT} -F OUTPUT
    if is_ipv6_enabled; then
        ${IPT6} -F OUTPUT
    fi

    ${IPT} -F LOG_DROP
    ${IPT} -F LOG_ACCEPT
    ${IPT} -F ONLYTRUSTED
    ${IPT} -F ONLYPRIVILEGIED
    ${IPT} -F NEEDRESTRICT
 
    ${IPT} -t mangle -F

    if is_docker_enabled; then
        ${IPT} -F DOCKER-USER
        ${IPT} -A DOCKER-USER -j RETURN

        ${IPT} -F MINIFW-DOCKER-PUB
        ${IPT} -X MINIFW-DOCKER-PUB
        ${IPT} -F MINIFW-DOCKER-PRIVILEGED
        ${IPT} -X MINIFW-DOCKER-PRIVILEGED
        ${IPT} -F MINIFW-DOCKER-TRUSTED
        ${IPT} -X MINIFW-DOCKER-TRUSTED
    else
        ${IPT} -t nat -F
    fi

    # Accept all
    ${IPT} -P INPUT ACCEPT
    if is_ipv6_enabled; then
        ${IPT6} -P INPUT ACCEPT
    fi

    ${IPT} -P OUTPUT ACCEPT
    if is_ipv6_enabled; then
        ${IPT6} -P OUTPUT ACCEPT
    fi
    #${IPT} -P FORWARD ACCEPT
    #${IPT} -t nat -P PREROUTING ACCEPT
    #${IPT} -t nat -P POSTROUTING ACCEPT

    # Delete non-standard chains
    ${IPT} -X LOG_DROP
    ${IPT} -X LOG_ACCEPT
    ${IPT} -X ONLYPRIVILEGIED
    ${IPT} -X ONLYTRUSTED
    ${IPT} -X NEEDRESTRICT

    echo "...flushing IPTables rules is now finish : OK"
}

status() {
    ${IPT} -L -n -v --line-numbers
    ${IPT} -t nat -L -n -v --line-numbers
    ${IPT} -t mangle -L -n -v --line-numbers
    ${IPT6} -L -n -v --line-numbers
    ${IPT6} -t mangle -L -n -v --line-numbers
}

reset() {
    echo "Reset all IPTables counters..."

    ${IPT} -Z
    if is_ipv6_enabled; then
        ${IPT6} -Z
    fi

    ${IPT} -t nat -Z

    ${IPT} -t mangle -Z
    if is_ipv6_enabled; then
        ${IPT6} -t mangle -Z
    fi

    echo "...reseting IPTables counters is now finish : OK"
}

case "$1" in
    start)
        echo "${NAME} version ${VERSION}"
        start
    ;;

    stop)
        echo "${NAME} version ${VERSION}"
        stop
    ;;

    status)
        echo "${NAME} version ${VERSION}"
        status
    ;;

    reset)
        echo "${NAME} version ${VERSION}"
        reset
    ;;

    restart)
        echo "${NAME} version ${VERSION}"
        stop
        start
    ;;

    *)
        echo "${NAME} version ${VERSION}"
        echo "Usage: $0 {start|stop|restart|status|reset}"
        exit 1
esac

exit 0
